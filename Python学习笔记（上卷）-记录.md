# 《Python学习笔记 上卷》 笔记.

1. 名字==字典容器.
2. 名字和目标对象关联构成强引用关系，会增加引用计数，影响对象生命周期.
3. 弱引用，保留引用前提，不增加计数，也不阻止回收.  (weakref )--应用场景，缓存，监控.
4. 三种方式执行字符串函数，exec eval, ast. literal_eval..
5. Python3将原int long 合并为int 采用可变长结构.
6. python2 与python3 除法有区别，python2 3/2=1 . python3 3/2=1.5 除法分2种方式/和// 前一种无论是否整除，都返回浮点数. 而//会截掉小数部分，保留整数.
7. python3 不支持数字与非数字比较操作
8. python 枚举 enum. Enum  .
9. float 是基于硬件的二进制.
10. join方法 预先计算出总长度，一次性分配内存，随后直接复制内存数据填充.
11. 字符串可能是进程中实例数量最多的类型之一，因为对象的名字就是字符串实例.
12. 容器类数据类型，乘法是复制内部元素.
13. Python的池化仅用于字符串,整数，而不用于容器类型.
14. 列表与数组长度不固定，按需扩张或收缩.
15. Python2 解释器采用ASCII为默认编码，如果源码里出现Unicode，无法解析报错.
16. 终止进程的正式做法是sys. exit(0),0代表正常退出. 其他异常.
17. 通常将进程内存分做堆和栈，堆可自由申请，通过指针存储自由数据;栈用于指令执行，与线程绑定. 在线程栈内存里，每个被调用函数都有一块保留地，我们称其为栈帧.
18. 通过函数sys._getframe 可访问调用堆栈内不同层级的栈帧对象，参数0为当前，1为上一级，以此类推.inspect + traceback 都可以是内省对象.
19. 当执行yield指令时，在设置好返回值后，解释器保存线程状态，并挂起当前函数流程.只有再次调用__next__方法时，才能回复状态，继续执行.如此以 ***yield***  为切换分界线，往复交替，直到函数结束.
20. 对生成器而言，suspend挂起点是一个安全位置，相关状态被临时冻结.E
21. 模块被导入时，编译成字节码，随后解释器创建模块实例.
22. 模块无论被导入多少次，在整个解释器进程内部仅有一个实例存在.

23. 动态导入方式有2种① 通过importlib.import_module ② 通过exec、eval、ast.litral_eval 动态解析字符串，然后再从sys.modules中获取该实例.

24. init.py 文件 在包或者内部模块首次导入时自动执行，且仅执行一次.

25. 函数dir 搜索所有可访问成员的名字，vars 直接返回__dict__属性.
26. 单下划线开头的变量，是私有变量，一般以* 号导入时，不会被导入.双下线开头的变量，一般是类内部对象，不会被继承引用，一般是通过_ClassName__Params 使用.

27. 面向对象的3个特征：封装，继承和多态
28. 封装讲求结构复用，逻辑内敛，以固定接口对外提供服务。其遵循单一职责，规定每个类型仅有一个引发变化的原因。多于一个的耦合设计会导致脆弱类型。任何职责变更都可能引发连带变故。单一封装的核心是解耦和内聚，这让设计更简单，清晰，代码更易测试和冻结，避免不确定性。
29. 继承并非要复制原有类型，而是一种增量进化，在遵循原有设计和不改变既有代码的前提下，添加新功能，或改进算法。其对应开闭原则，对修改封闭，对扩展开放。缺点是带来维护上的麻烦，其天生的基于实现的依赖方式导致耦合大范围存在。

30. 生成器是一种惰性计算,含有yield关键字的函数或者方法，调用时，并会直接执行内部code，而是直接返回一个生成器(迭代器)，当开始用for 运行时，函数或方法内部的code 开始执行，直到执行到yield 关键字位置，返回第一个值之后，挂起。直到下一次的for循环唤醒。再重复以上的步骤。
31. \__repr__方法倾向于输出运行前状态，是和调试和观察。\__str__ 通常返回内容数据，其面向用户易于阅读可输出到终端或日志。
32. \__getattr__:当整个搜索路径都找不到目标属性时触发
33. \__setattr__:拦截对任何属性的赋值操作
34. \__delattr__： 拦截对任何属性的删除操作。
35. \__getattribute__: 拦截任何势力属性的访问。
36. 常见的错误处理方式有两类：一类是返回错误码，由调用方决定如何处理;另一类是以专用语句保护代码块，当异常发生时，跳转到指定的处理单元。前者有较好的性能，而后者可分离正常逻辑与故障处理代码。
37. 异常对象被保存在当前线程状态里，可用sys.exc_info 获取当前错误堆栈信息。
38. 当用try保护代码时，异常一旦发生，立即跳出当前try代码块进入到except 异常处理流程。
39. 被捕获的异常可以重新抛出，使用raise 放置在except 代码块中。
40. 即便在try语句中执行return break 解释器也会确保继续执行finally。
41. try 语句不执行的话，finally 也不会被执行。
42. 内置异常多以Error 结尾，但建议以Exception，Error 后缀区分可修复异常和不可修复异常。
43. 上下文管理协议:实现了\__enter__ 和\__exit__ 方法，enter方法用于返回对象自己，exit 做收尾清理。
44. 上下文管理器作用，不仅可以参与用户逻辑处理，还可以用于测量执行性能，记录日志重新抛出，启动调试器。
